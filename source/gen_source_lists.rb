
require 'find'

# set this to false to remove all those 'found ...' displays
verbose = false

# this routine essentially just replaces the folder slashes to underscores
def folderToProjectName(folder)
  folder.gsub(/\./, "_")
end

# loop through the folder contents looking for files to add
# to the project
def processFolder(outfile, folder, baseFolder, verbose)
  if verbose then
    puts "scanning #{folder}..."
  end

  proj_name = folderToProjectName(folder)
  final_str = "SET(#{proj_name}_SRCS\n"

  # scan for the source files we need
  Dir[folder +'/*.*'].each { |path|
    if ! FileTest.directory?(path)
      fileName = File.basename(path)
      # match *.c and *.cpp files only
      if fileName =~ /\.(((c|C)[pp])|h)/
        final_str << "  \"#{baseFolder}/#{path}\"\n"
        if verbose then
          puts "found #{path}"
        end
      end
    end
  }

  # terminate and write it out
  final_str << "  )\n\n"
  outfile << final_str
end

# parse the command line and check if we need to nuke the drive[colon] combos
nukeDriveSpec = false #(ARGV.size > 0) and (ARGV[0] =~ /MinGW/)

# place all the source directories in this array
# IMPORTANT: pre-requisite library MUST be preceded their dependents!
lib_sources = ["YAGSupport", "YAGInput", "YAGDisplay", "YAGCore"]
gui_apps = ["TApplication", "TGameBasic", "TGameApplication", "TGameExtended", "PyramidSolitaire"]
console_apps = ["yipp"]
extra_lib_sources = ["3rdParty/FreeImage", "3rdParty/FreeSL/lib"]
extra_includes = ["3rdParty/FreeImage", "3rdParty/FreeSL/include"]

# get the current directory and work out whether it has a drive spec
this_folder = Dir.getwd
subs_to_nuke = (nukeDriveSpec and this_folder.include?(":")) ? this_folder[0,2] : nil

# open the file and
outfile = File.new("SourceFiles.txt", "w")
outfile << "# This file is auto-generated by gen_source_lists.rb. Do not edit.\n\n"

# create folder macros
projRoot = File.expand_path("../")
libDest = File.expand_path("../lib")
exeDest = File.expand_path("../bin")

# and clean them up
if(subs_to_nuke)
  this_folder.delete!(subs_to_nuke)
  projRoot.delete!(subs_to_nuke)
  libDest.delete!(subs_to_nuke)
  exeDest.delete!(subs_to_nuke)
end

outfile << "SET(SOURCE_ROOT \"#{this_folder}\")\n"
outfile << "SET(PROJECT_ROOT \"#{projRoot}\")\n"
outfile << "SET(LIBDEST \"#{libDest}\")\n"
outfile << "SET(EXEDEST \"#{exeDest}\")\n\n"

# display the directories generated
if verbose then
  puts "Library destination = #{libDest}"
  puts "RunTime destination = #{exeDest}"
end

# create path strings to where directx and boost are located
dxPath = ENV['DXSDK_DIR'].gsub(/\\/, "/")
boostPath = ENV['BOOST_DIR'].gsub(/\\/, "/")

# configure extra lib paths
outfile << "LINK_DIRECTORIES(\"#{libDest}\"\n"
outfile << "  \"#{boostPath}/Lib/\"\n"
outfile << "  \"#{dxPath}/Lib/\"\n"
outfile << "  \"#{dxPath}/Lib/x86/\"\n"
extra_lib_sources.each { |s| outfile << "  \"#{projRoot}/#{s}\"\n" }
outfile << "  )\n\n"

# process the libraries first
inc_folders = "INCLUDE_DIRECTORIES(BEFORE\n"
extra_includes.each { |s| inc_folders << "  \"#{projRoot}/#{s}\"\n" }
lib_sources.each { |folder|
  inc_folders << "  \"#{this_folder}/#{folder}/\"\n"
  processFolder(outfile, folder, this_folder, verbose)
}
inc_folders << "  \"#{boostPath}/\"\n"
inc_folders << "  \"#{dxPath}/Include/\"\n"
inc_folders << "  )\n\n"
outfile << inc_folders

# process dependent apps
gui_apps.each { |folder| processFolder(outfile, folder, this_folder, verbose) }
console_apps.each { |folder| processFolder(outfile, folder, this_folder, verbose) }

# create the lists
# libraries first
outfile << "SET(LIB_PROJECTS\n"
libAdds = ""
lib_sources.each { |s|
  prj = folderToProjectName(s)
  libAdds << "ADD_LIBRARY(#{prj} ${#{prj}_SRCS})\n"
  outfile << "  #{prj}\n"
}
outfile << "  )\n\n"
# applications
outfile << "SET(DEPENDENT_APPS\n"
appAdds = ""
gui_apps.each { |s|
  prj = folderToProjectName(s)
  appAdds << "ADD_EXECUTABLE(#{s} WIN32 ${#{prj}_SRCS})\n"
  outfile << "  #{s}\n"
}
console_apps.each { |s|
  prj = folderToProjectName(s)
  appAdds << "ADD_EXECUTABLE(#{s} ${#{prj}_SRCS})\n"
  outfile << "  #{s}\n"
}
outfile << "  )\n\n"
# the add statements
outfile << libAdds
outfile << appAdds


